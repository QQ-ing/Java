# Java里各种乱七八糟的锁概念及实现

### 重量级锁

### 轻量级锁

### 自旋锁（Spin Lock）

自旋锁是一种非阻塞锁。线程获取锁时，如果锁已经被其他线程占有时，并不会挂起，而是使用循环不停地判断锁的状态，直至获得锁。

Java里的自旋锁是采用CAS来实现的，CPU保证了CAS的原子性。伪代码如下：

```Java
public class SpinLock {
    private final AtomicReference<Thread> lock = new AtomicReference<>(null);
    
    public void lock() {
        Thread thread = Thread.currentThread();
        while(true) {
            if (lock.compareAndSet(nul, thread)) break;
            if (lock.get() == thread) break;  // 支持可重入
        }
    }
    
    public void unlock() {
        Thread current = Thread.currentThread();  
    	lock.compareAndSet(current, null);  
    }
}
```

自旋锁适用于多核CPU下，资源竞争少，预计线程等待锁少于线程上下文切换时间的情况。

### 互斥量/阻塞锁（Mutex）

互斥量是阻塞锁，当线程无法获取锁时被挂起（wait），当其他线程释放锁（互斥量）后，操作系统会唤醒（notify）等待锁的线程，让其进行竞争去获得锁。

`synchronized`、`ReentrantLock`、`LockSupport `、`Object.notify()`、`Object.wait()`等设计到线程挂起唤醒的都是互斥锁的实现。

阻塞锁适用于单核或者CPU核心数很少或资源竞争大，上下文切换时间相对较少的情况。

### 锁升级/降级

### 锁消除（Lock Elision）

锁消除是JIT的一种优化策略。当JIT通过逃逸技术分析发现同步块里面的代码并没有共享变量，不存在线程安全问题时，就会将同步代码块的锁去掉，以达到优化性能的目的。

### 偏向锁

偏向锁的出现基于这样一种情况：大多数情况锁不仅不存在多线程竞争，而且总是由同一线程线程多次获得。在这种情况下，为了消除线程锁重入的开销，而引入的一种优化机制。

偏向锁的获取与撤销：

> **偏向锁的获取**： 线程获取锁时，先测试对象头里偏向锁指向的线程ID是否为当前线程，如果测试成功则获得锁，如果测试失败，则判断继续判断对象头里偏向锁标识是否为1，如果是则表示当前是偏向锁，则使用CAS将对象头的偏向锁指向当前线程，否则使用CAS竞争锁。
>
> **偏向锁的获取**： 略！

### 公平锁/非公平锁

### 读写锁

### 可重入锁

### 锁碰撞

### 锁粗化

### 锁膨胀

### 乐观锁

### 悲观锁

### 对象锁


## 参考资料

* https://docs.oracle.com/cd/E13150_01/jrockit_jvm/jrockit/geninfo/diagnos/thread_basics.html
* http://www.blogjava.net/security/archive/2009/02/16/jvm_thin-lock_fat-lock__spin-lock_tasuki-lock.html
* https://www.zhihu.com/question/38857029
* http://www.cnblogs.com/paddix/p/5405678.html
