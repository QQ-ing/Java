# Java里各种乱七八糟的锁概念及实现

### 重量级锁

### 轻量级锁

### 自旋锁（Spin Lock）

自旋锁是一种非阻塞锁。线程获取锁时，如果锁已经被其他线程占有时，并不会挂起，而是使用循环不停地判断锁的状态，直至获得锁。

Java里的自旋锁是采用CAS来实现的，CPU保证了CAS的原子性。伪代码如下：

```Java
public class SpinLock {
    private final AtomicReference<Thread> lock = new AtomicReference<>(null);
    
    public void lock() {
        Thread thread = Thread.currentThread();
        while(true) {
            if (lock.compareAndSet(nul, thread)) break;
            if (lock.get() == thread) break;  // 支持可重入
        }
    }
    
    public void unlock() {
        Thread current = Thread.currentThread();  
    	lock.compareAndSet(current, null);  
    }
}
```

自旋锁适用于多核CPU下，资源竞争少，预计线程等待锁少于线程上下文切换时间的情况。

### 互斥量/阻塞锁（Mutex）

互斥量是阻塞锁，当线程无法获取锁时被挂起（wait），当其他线程释放锁（互斥量）后，操作系统会唤醒（notify）等待锁的线程，让其进行竞争去获得锁。

`synchronized`、`ReentrantLock`、`LockSupport `、`Object.notify()`、`Object.wait()`等设计到线程挂起唤醒的都是互斥锁的实现。

阻塞锁适用于单核或者CPU核心数很少或资源竞争大，上下文切换时间相对较少的情况。

### 锁升级/降级

### 锁消除

### 公平锁/非公平锁

### 读写锁

### 可重入锁

### 互斥锁

### 锁碰撞

### 锁粗化

### 锁膨胀

### 乐观锁

### 悲观锁

### 对象锁


## 参考资料

* https://docs.oracle.com/cd/E13150_01/jrockit_jvm/jrockit/geninfo/diagnos/thread_basics.html
* http://www.blogjava.net/security/archive/2009/02/16/jvm_thin-lock_fat-lock__spin-lock_tasuki-lock.html
* https://www.zhihu.com/question/38857029
