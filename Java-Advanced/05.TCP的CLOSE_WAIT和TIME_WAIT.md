# TCP的CLOSE_WAIT和TIME_WAIT 

难免会遇到TCP的CLOSE_WAIT和TIME_WAIT过多的情况，了解这个两个状态值对调优具有十分重要的重用。

### 四次挥手

下面是TCP的断开协议（四次挥手）的状态图。需要注意的是，图里所示的断开方为Client，而实际情况下，断开也可以是Server。

![](img/tcp-close_wait-time_wait.jpg)

#### FIN_WAIT_1

主动断开方会发送FIN给对端，表示要断开TCP连接，同时自己进入**FIN_WAIT_1**状态。

#### CLOSE_WAIT

被动断开方收到FIN后，回应ACK并进入**CLOSE_WAIT**状态，此时并没有直接发送**FIN&ACK**，主要是因为被动关闭的一方，可能还有数据未发送完，需要时间窗口发送数据，所以进入的是**CLOSE_WAIT**状态，并发送数据（也可能没有数据）。

### LAST_ACK

被动断开方，发送完数据之后，向对端发送**FIN&ACK**表示数据已经发送完毕，可以正式关闭连接，并进入**LAST_ACK**状态，等待最终关闭确认。

#### TIME_WAIT

主动断开方收到**FIN&ACK**之后，确认被动端开方已经发送完数据可以正式关闭。此时，如果主动断开方已经接受完数据包，则可以向对端发送**ACK**，自己进入**TIME_WAIT**状态。此时，被动断开方的所有操作已经完成，只要等待2MSL的超时时间，就可以进入**CLOSED**状态。

#### CLOSE

被动断开方收到最后的**ACK**之后直接进入**CLOSE**状态。需要注意的是，主动断开方需要等待2MSL的时间。

### TIME_WAIT为什么需要等待2MSL

TIME_WAIT需要等待2MSL时间，主要是为了确保双方正常关闭。在主动端开方发送最后一个ACK之后，这个ACK可能会丢失，或者超时，导致被动端开方超时发送**FIN&ACK**，如果此时主动端开方已经进入**CLOSE**状态，则被动端开方会抛出**connect reset**的错误。

还有一个原因就是给足够的时间让数据包在网络中及时传送到目标，避免新的同一个端口同一个对端的连接的数据包混淆。想象一下，如果在断开的AB两端，快速建立TCP连接，此时第二次连接的TCP包可能会先于第一次的数据包到达对端，你让接收方情何以堪？