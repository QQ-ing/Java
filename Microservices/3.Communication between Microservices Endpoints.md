# Communication between Microservices Endpoints

## Orchestration versus Choreography

### Orchestration

There will be a mediator service that will act as the brain or conductor of the orchestra (number of microservices assembled). This mediator service will trigger and ask each microservice to start the action. All microservices should be working towards a single business purpose.

There are challenges in this approach. Here, the mediator service becomes the central authority, and all the logic starts residing here, which is not a good microservice design. Logic inside the mediator service leads to lots of dependency between services.

Running, maintaining, and keeping this mediator service up is the cost of this pattern, but another thing is that it becomes the single point of failure in the whole architecture. This can be handled with better tooling and cloud-based techniques such as scaling, clustering, and so on. In addition to this, the orchestration model is not easy to implement in a complex domain. If you have one decision maker or controller, it becomes hard to follow the distributed design.

### Choreography

In choreography, each service talks to another service after finishing its work or, sometimes, also between its work to trigger or initiate the task in the next service. This communication can happen in a one-to-one, one-to-many, or many-to-many fashion. Like in orchestration, choreography can happen in a synchronous way or asynchronous way. Ideally, in choreography, there is a global protocol on which each service decides to communicate with each other. Choreography is preferred to be used with asynchronous communication. As there is no central service, each component just raises the event when it finishes its task, which makes the services decoupled and independent of each other. Each component will be listening to an event or message raised by another service and reacting to those messages.

## Synchronous versus asynchronous communication

### Synchronous

### Asynchronous
