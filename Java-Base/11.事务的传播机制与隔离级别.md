#11.事务的传播机制与隔离级别

__事务的传播机制控制着事务的适用范围。__

下图说明了控制事务范围的重要性：Bean-1的method-A开启一个事务，然后调用Bean-2的method-B方法，当method-B执行时，需要启动一个新的事务或者采用method-A方法已有的事务，这取决于method-B的事务属性(Transaction Attributes)。

![事务的适用范围](http://docs.oracle.com/cd/E19226-01/820-7627/images/trans-transactionScope.gif)
 
##11.1 事务属性

事务属性以及说明如下：

事务属性     |  说明
------------ | -------------
__Required__     | Required告诉容器，目标对象方法需要一个事务。如果事务上下文已经存在，容器则使用该事务，否则，容器将为此方法开启一个新事务。
__RequiresNew__  | 当对象方法被调用时，总是需要开启一个新的事务。如果先于方法调用前一个事务已经开启了，此事务将被暂时挂起，容器启动一个新的事务。当这个新事务随着方法调用完成终止后，老的事务将会继续。
__Mandatory__    | 当使用这个事务属性时，当方法被调用时，一个事先存在的事务上下文必须存在。如果此事务上下文不存在，容器将会抛出一个TransactionRequiredException，宣告它需要一个已存在的事务，但此事务没有找到。
__Supports__     | 告知容器，如果目标对象方法在事务范围内，则使用该事务；如果不存在，则不使用事务。
__NotSupported__ | 告知容器，被调用的对象方法不使用事务。如果一个事务已启动，容器会将此事务暂停直至方法调用结束。如果调用方法时没有事务存在，容器也不会为此方法开启任何事务。
__Never__        | 告知容器，目标对象方法不需要事。在调用目标对象方法时，如果事务上下文存在，则抛出RemoteException异常。

在Spring中，还支持了另外一种属性：__Nested__，该属性告知Spring进行事务嵌套，并采用Required属性。

##11.2 事务隔离级别

__事务隔离级别是指交织在一起的事务之间互相影响的程度，它决定了在其他事务访问和更新同一份数据时，一个事务对更新所允许的可见程度。__

隔离性是事务的四大特征（原子性，一致性，隔离性，持久性）之一，事务隔离分为不同级别，分别为：

隔离级别                       | 说明
-------------------------------|-----------------------
__未授权读(Read uncommitted)__ |最低的隔离级别。允许脏读(dirtyreads)，事务可以看到其他事务“尚未提交”的修改。很多数据库厂商并不支持这一隔离级别（包括Oracle）。
__授权读(Read committed)__     |该隔离级别设置允许多个事务访问同一份数据，但将未提交的数据对其他事务隐藏，直至数据提交。
__可重复读(Repeatable reads)__ |这一隔离级别保证，一旦在某一事务中读取了数据库的一个值集，在后续的每次查询操作中都读到同样的值。
__可序列化(Serializable)__     |最高的隔离级别，保证所有的事务串行执行。

EJB和Spring的这些事务隔离设置依赖于底层数据库。也就是说，虽然编程框架支持上述种种隔离级别设定，但需要底层数据库也要支持这些级别设定，设定才会生效。如果数据库不支持某一个设定级别，而应用框架这样设置了，数据库将会采用缺省的隔离级别。

##11.3 脏读、幻读、不可重复读等定义

### 脏读

### 幻读

### 不可重复读

## 参考资料

  * http://docs.oracle.com/cd/E19226-01/820-7627/6nisfjnao/index.html
  * 《Java事务设计策略》
  * 《Java内存模型》
  * 维基百科(事务隔离)：http://zh.wikipedia.org/zh/%E4%BA%8B%E5%8B%99%E9%9A%94%E9%9B%A2
  * 维基百科(ACID)：http://zh.wikipedia.org/wiki/ACID
